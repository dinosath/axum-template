use e2e::{base_url, http_client};
{% if frontend != 'none' %}
use e2e::{browser, TestBrowser};
{% endif %}
use rstest::rstest;

// ============================================================================
// API Tests - Always run (container-based)
// ============================================================================

#[rstest]
#[tokio::test]
async fn test_api_health(
    #[future] base_url: String,
    http_client: reqwest::Client,
) {
    let base_url = base_url.await;
    
    let response = http_client
        .get(format!("{}/api/health", base_url))
        .send()
        .await
        .expect("Failed to call health endpoint");
    
    assert!(response.status().is_success(), "Health endpoint should return success");
}

{% if frontend != 'none' %}
// ============================================================================
// UI Tests - Only when frontend is enabled
// ============================================================================

#[rstest]
#[tokio::test]
async fn test_homepage_loads(
    #[future] base_url: String,
    #[future] browser: TestBrowser,
) {
    let base_url = base_url.await;
    let browser = browser.await;
    
    let page = browser.browser.new_page().await.expect("Failed to create page");
    page.goto(&base_url, None).await.expect("Failed to navigate");

    let title = page.title().await.expect("Failed to get title");
    assert!(!title.is_empty(), "Page title should not be empty");
    
    browser.browser.close().await.expect("Failed to close browser");
}

#[rstest]
#[tokio::test]
async fn test_frontend_static_assets(
    #[future] base_url: String,
    http_client: reqwest::Client,
) {
    let base_url = base_url.await;
    
    // Test that the main frontend entry point is accessible
    let response = http_client
        .get(&base_url)
        .send()
        .await
        .expect("Failed to load frontend");
    
    assert!(response.status().is_success(), "Frontend should be accessible");
    
    let content_type = response
        .headers()
        .get("content-type")
        .map(|v| v.to_str().unwrap_or(""))
        .unwrap_or("");
    
    assert!(
        content_type.contains("text/html"),
        "Frontend should return HTML content"
    );
}

#[rstest]
#[tokio::test]
async fn test_login_page_renders(
    #[future] base_url: String,
    #[future] browser: TestBrowser,
) {
    let base_url = base_url.await;
    let browser = browser.await;
    
    let page = browser.browser.new_page().await.expect("Failed to create page");
    page.goto(&format!("{}/login", base_url), None).await.expect("Failed to navigate to login");

    // Wait for the page to load
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
    
    // Check that login form elements exist by evaluating JavaScript to get page content
    let body = page.evaluate_value("document.body.innerHTML").await.expect("Failed to get page content");
    assert!(
        body.contains("login") || body.contains("Login") || body.contains("sign") || body.contains("Sign"),
        "Login page should contain login-related content"
    );
    
    browser.browser.close().await.expect("Failed to close browser");
}
{% endif %}
