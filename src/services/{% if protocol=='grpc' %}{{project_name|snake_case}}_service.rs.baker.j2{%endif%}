{% import "macros.jinja" as macros -%}
use tonic::{Request, Response, Status};
use log::{debug, error};
use sea_orm::{ActiveModelTrait, DatabaseConnection, EntityTrait, IntoActiveModel, ModelTrait, Set, ActiveEnum};
use crate::services::grpc_utils::find_model_by_id;
use chrono::{Utc, NaiveDateTime};

pub mod {{ project_name | snake_case }}_proto {
    tonic::include_proto!("{{ project_name | snake_case }}");
}

pub use {{ project_name | snake_case }}_proto::*;
{% for entity_name,entity in entities | items -%}
{% if entity.attributes | items %}
{% set message = entity_name | pascal_case -%}
{% set message_plural = entity_name | plural | pascal_case -%}
{% set message_snake = entity_name | snake_case -%}
{% set message_snake_plural = entity_name | plural | snake_case -%}
pub use {{ project_name | snake_case }}_proto::{{ message_snake }}_service_server::{{ message }}ServiceServer;
{% endif -%}
{% endfor %}

{% for entity_name,entity in entities | items -%}
{% if entity.attributes | items %}
{% set message = entity_name | pascal_case -%}
{% set message_plural = entity_name | plural | pascal_case -%}
{% set message_snake = entity_name | snake_case -%}
{% set message_snake_plural = entity_name | plural | snake_case -%}
use crate::models::{{ message_snake }}::{ActiveModel as {{ message }}ActiveModel, Entity as {{ message }}Entity, Model as {{ message }}Model};
{% for attr_name, attr in entity.attributes | items -%}
{% if attr.enum -%}
use crate::models::{{ message_snake }}::{{ attr_name | pascal_case }} as {{ message }}{{ attr_name | pascal_case }};
{% endif -%}
{% endfor -%}
{% endif -%}
{% endfor %}
{% for entity_name,entity in entities | items -%}
{% if entity.attributes | items %}
{% set message = entity_name | pascal_case -%}
{% set message_plural = entity_name | plural | pascal_case -%}
{% set message_snake = entity_name | snake_case -%}
{% set message_snake_plural = entity_name | plural | snake_case -%}

// ============================================
// {{ message }}Service Implementation
// ============================================

#[derive(Clone)]
pub struct {{ message }}ServiceImpl {
    db: DatabaseConnection,
}

impl {{ message }}ServiceImpl {
    pub fn new(db: DatabaseConnection) -> Self {
        Self { db }
    }
}

fn {{ message_snake }}_create_request_to_active_model(req: Create{{ message }}Request) -> {{ message }}ActiveModel {
    let now = Utc::now().naive_utc();
    {{ message }}ActiveModel {
        created_at: Set(now),
        last_updated: Set(now),
        {% for name, property in entity.attributes | items -%}
        {% if macros.relation_has_fk(property)=='true' -%}
        {# Relation field with FK - convert string to i32 foreign key #}
        {% if property.required -%}
        {{ name | snake_case }}_id: Set(req.{{ name | snake_case }}.and_then(|s| s.parse::<i32>().ok()).unwrap_or(0)),
        {% else -%}
        {{ name | snake_case }}_id: Set(req.{{ name | snake_case }}.and_then(|s| s.parse::<i32>().ok())),
        {% endif -%}
        {% elif macros.is_relation(property)=='true' -%}
        {# Relation without FK (oneToMany, manyToMany, inverse oneToOne) - skip #}
        {% elif property.enum -%}
        {# Enum field - convert string to enum using ActiveEnum::try_from_value #}
        {{ name | snake_case }}: Set(req.{{ name | snake_case }}.and_then(|s| {{ message }}{{ name | pascal_case }}::try_from_value(&s).ok()).unwrap_or_default()),
        {% elif property.type == 'datetime' or property.type == 'timestamp' -%}
        {# DateTime field - convert string to NaiveDateTime #}
        {% if property.required -%}
        {{ name | snake_case }}: Set(req.{{ name | snake_case }}.and_then(|s| NaiveDateTime::parse_from_str(&s, "%Y-%m-%dT%H:%M:%S%.f").ok()).unwrap_or(now)),
        {% else -%}
        {{ name | snake_case }}: Set(req.{{ name | snake_case }}.and_then(|s| NaiveDateTime::parse_from_str(&s, "%Y-%m-%dT%H:%M:%S%.f").ok())),
        {% endif -%}
        {% elif property.required -%}
        {{ name | snake_case }}: Set(req.{{ name | snake_case }}.unwrap_or_default()),
        {% else -%}
        {{ name | snake_case }}: Set(req.{{ name | snake_case }}),
        {% endif -%}
        {% endfor %}
        ..Default::default()
    }
}

fn {{ message_snake }}_entity_to_reply(item: {{ message }}Model) -> {{ message }} {
    {{ message }} {
        id: item.id.to_string(),
        {% for name, property in entity.attributes | items -%}
        {% if macros.relation_has_fk(property)=='true' -%}
        {# Relation field with FK - convert i32 foreign key to string #}
        {% if property.required -%}
        {{ name | snake_case }}: Some(item.{{ name | snake_case }}_id.to_string()),
        {% else -%}
        {{ name | snake_case }}: item.{{ name | snake_case }}_id.map(|id| id.to_string()),
        {% endif -%}
        {% elif macros.is_relation(property)=='true' -%}
        {# Relation without FK (oneToMany, manyToMany, inverse oneToOne) - skip #}
        {% elif property.enum -%}
        {# Enum field - convert enum to string using into_value #}
        {{ name | snake_case }}: Some(item.{{ name | snake_case }}.into_value()),
        {% elif property.type == 'datetime' or property.type == 'timestamp' -%}
        {# DateTime field - convert NaiveDateTime to string #}
        {% if property.required -%}
        {{ name | snake_case }}: Some(item.{{ name | snake_case }}.format("%Y-%m-%dT%H:%M:%S%.f").to_string()),
        {% else -%}
        {{ name | snake_case }}: item.{{ name | snake_case }}.map(|dt| dt.format("%Y-%m-%dT%H:%M:%S%.f").to_string()),
        {% endif -%}
        {% elif property.required -%}
        {{ name | snake_case }}: Some(item.{{ name | snake_case }}),
        {% else -%}
        {{ name | snake_case }}: item.{{ name | snake_case }},
        {% endif -%}
        {% endfor %}
        ..Default::default()
    }
}

#[tonic::async_trait]
impl {{ message_snake }}_service_server::{{ message }}Service for {{ message }}ServiceImpl {
    async fn create(&self, request: Request<Create{{ message }}Request>) -> Result<Response<{{ message }}>, Status> {
        debug!("received create request: {:?}", request);
        let active_model = {{ message_snake }}_create_request_to_active_model(request.into_inner());
        let model = active_model.insert(&self.db).await.map_err(|e| Status::internal(e.to_string()))?;
        let reply = {{ message_snake }}_entity_to_reply(model);
        let response = Response::new(reply);
        debug!("responding with: {:?}", response);
        Ok(response)
    }

    async fn get(&self, request: Request<Get{{ message }}Request>) -> Result<Response<{{ message }}>, Status> {
        debug!("received get request: {:?}", request);
        let model = find_model_by_id::<{{ message }}Entity>(&self.db, request.into_inner().id.as_str()).await?;
        let reply = {{ message_snake }}_entity_to_reply(model);
        debug!("responding with: {:?}", reply);
        Ok(Response::new(reply))
    }

    async fn update(&self, request: Request<Update{{ message }}Request>) -> Result<Response<{{ message }}>, Status> {
        debug!("received update request: {:?}", request);
        let req = request.into_inner();
        let model = find_model_by_id::<{{ message }}Entity>(&self.db, req.id.as_str()).await?;
        let mut active_model = model.into_active_model();
        let now = Utc::now().naive_utc();
        active_model.last_updated = Set(now);
        {% for name, property in entity.attributes | items -%}
        {% if macros.relation_has_fk(property)=='true' -%}
        {# Relation field with FK - convert string to i32 foreign key #}
        {% if property.required -%}
        active_model.{{ name | snake_case }}_id = Set(req.{{ name | snake_case }}.and_then(|s| s.parse::<i32>().ok()).unwrap_or(0));
        {% else -%}
        active_model.{{ name | snake_case }}_id = Set(req.{{ name | snake_case }}.and_then(|s| s.parse::<i32>().ok()));
        {% endif -%}
        {% elif macros.is_relation(property)=='true' -%}
        {# Relation without FK (oneToMany, manyToMany, inverse oneToOne) - skip #}
        {% elif property.enum -%}
        {# Enum field - convert string to enum using ActiveEnum::try_from_value #}
        active_model.{{ name | snake_case }} = Set(req.{{ name | snake_case }}.and_then(|s| {{ message }}{{ name | pascal_case }}::try_from_value(&s).ok()).unwrap_or_default());
        {% elif property.type == 'datetime' or property.type == 'timestamp' -%}
        {# DateTime field - convert string to NaiveDateTime #}
        {% if property.required -%}
        active_model.{{ name | snake_case }} = Set(req.{{ name | snake_case }}.and_then(|s| NaiveDateTime::parse_from_str(&s, "%Y-%m-%dT%H:%M:%S%.f").ok()).unwrap_or(now));
        {% else -%}
        active_model.{{ name | snake_case }} = Set(req.{{ name | snake_case }}.and_then(|s| NaiveDateTime::parse_from_str(&s, "%Y-%m-%dT%H:%M:%S%.f").ok()));
        {% endif -%}
        {% elif property.required -%}
        active_model.{{ name | snake_case }} = Set(req.{{ name | snake_case }}.unwrap_or_default());
        {% else -%}
        active_model.{{ name | snake_case }} = Set(req.{{ name | snake_case }});
        {% endif -%}
        {% endfor %}
        let updated = active_model.update(&self.db).await.map_err(|e| Status::internal(e.to_string()))?;
        let reply = {{ message_snake }}_entity_to_reply(updated);
        let response = Response::new(reply);
        debug!("responding with: {:?}", response);
        Ok(response)
    }

    async fn delete(&self, request: Request<Delete{{ message }}Request>) -> Result<Response<()>, Status> {
        debug!("received delete request: {:?}", request);
        let model = find_model_by_id::<{{ message }}Entity>(&self.db, request.into_inner().id.as_str()).await?;
        model.delete(&self.db).await.map_err(|e| {
            error!("cannot perform deletion of entity {:?}", e);
            Status::internal(e.to_string())
        })?;
        let response = Response::new(());
        debug!("responding with: {:?}", response);
        Ok(response)
    }

    async fn list(&self, request: Request<List{{ message_plural }}Request>) -> Result<Response<List{{ message_plural }}Response>, Status> {
        debug!("received list request: {:?}", request);

        let models = {{ message }}Entity::find().all(&self.db).await.map_err(|e| {
            error!("Database error: {}", e);
            Status::internal("Internal server error")
        })?
            .into_iter()
            .map({{ message_snake }}_entity_to_reply)
            .collect();
        let reply = List{{ message_plural }}Response {
            {{ message_snake_plural }}: models,
            next_page_token: String::new(),
        };
        let response = Response::new(reply);
        debug!("responding with: {:?}", response);
        Ok(response)
    }
}
{% endif -%}
{% endfor -%}