use axum::Router;
use log::{info, {{ 'error' if use_sqlx_migrations }}};
{% if database=='postgres' -%}
use sea_orm::{Database, DatabaseConnection};
{{ 'use sqlx::postgres::PgPoolOptions;' if use_sqlx_migrations -}}
{% endif -%}
use std::{env, error::Error};
use tokio::net::TcpListener;
use crate::app_state::AppState;
{% if authentication=='jwt'-%}
use crate::services::auth::setup_auth_state;
{% endif -%}
{% if static_includes | length > 0 -%}
use static_serve::embed_assets;

{% for entry in static_includes -%}
embed_assets!("{{ entry.assets_dir }}", compress = true, strip_html_ext = true);
{% endfor -%}
{%- endif %}

{% if database=='postgres'-%}
pub async fn init_db() -> Result<DatabaseConnection, Box<dyn std::error::Error>> {
    let database_url = env::var("DATABASE_URL").unwrap_or_else(|_| "postgres://postgres:postgres@localhost:5432".to_string());
    let db: DatabaseConnection = Database::connect(&database_url).await?;
    {% if use_sqlx_migrations -%}
    info!("ðŸ”„ Running database migrations...");
    let pool = PgPoolOptions::new().max_connections(5).connect(&database_url).await?;
    if let Err(e) = sqlx::migrate!("./migrations").run(&pool).await { error!("âŒ Failed migrations: {e}"); return Err(e.into()); }
    info!("âœ… Database migrations completed successfully!");
    {% else %}
    db.get_schema_registry("{{project_name}}::models::*").sync(&db).await?;
    {% endif -%}
    Ok(db)
}
{% endif -%}

pub async fn run() -> Result<(), Box<dyn Error>> {
    dotenvy::dotenv().ok();
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("info")).init();

    {% if database=='postgres'-%}
    let db= init_db().await?;
    {% endif -%}

    let port_env = env::var("PORT").unwrap_or_else(|_| "8080".to_string());
    let requested_port: u16 = port_env.parse().unwrap_or(8080);

    let listener = TcpListener::bind(format!("[::]:{}", requested_port)).await?;
    let actual_port = listener.local_addr()?.port();
    info!("Server starting on port {}", actual_port);

    {% if authentication=='jwt' -%}
    let (auth_state) = setup_auth_state(&&db).await;
    {% endif -%}
    let state = AppState {
        {{- 'db,' if database=='postgres' -}}
        {% if authentication=='jwt' -%}
        account_repository: auth_state.account_repository,
        secrets_repository: auth_state.secrets_repository,
        jwt_codec: auth_state.jwt_codec,
        cookie_template: auth_state.cookie_template,
        {% endif -%}
    };
    let app = Router::new()
        {{ '.merge(static_router())' if static_includes | length > 0 }}
        {{ '.nest("/auth", crate::services::auth::auth_routes())' if protocol=='rest' and authentication=='oidc' }}
        .nest("/api", crate::controllers::routes())
        .with_state(state);

    axum::serve(listener, app).await?;
    Ok(())
}
