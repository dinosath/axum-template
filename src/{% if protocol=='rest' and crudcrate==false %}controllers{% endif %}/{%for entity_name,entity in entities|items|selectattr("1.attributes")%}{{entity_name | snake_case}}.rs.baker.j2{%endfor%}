{% import "macros.jinja" as macros -%}
{% import "rust/types.jinja" as rust_types -%}
{% set model = entity_name | plural | pascal_case -%}
use serde_json::json;
use axum::{Router, extract::{Path, State}, http::{HeaderMap, HeaderValue, StatusCode}, routing::{delete, get, patch, post, put}, response::IntoResponse, Json};
use serde::{Deserialize, Serialize};
use sea_orm::{ActiveModelTrait, ModelTrait, EntityTrait, Set, IntoActiveModel, ConnectionTrait};
use sea_orm::EntityLoaderTrait;
use sea_orm::prelude::*;
use crate::app_state::AppState;
use crate::models::{{ rust_types.identifier(entity_name) }}::{ActiveModel, Entity, Model, ModelEx, {% for name,property in entity.attributes | items | selectattr('1.enum') -%}{{ rust_types.identifier(name) | pascal_case }}{% endfor -%}};
{% if entity.attributes | items | selectattr('1.type','equalto','relation') | length > 0 -%}
use super::{ {%- for rel in macros.get_all_relations(entity)|split(',') %}{{ rust_types.identifier(rel| trim | snake_case)  }}::{{rel | pascal_case}} as {{ rel | trim | pascal_case}}{% if not loop.last %}, {% endif -%}{% endfor -%} };
{% endif -%}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct {{ entity_name | pascal_case }} {
    pub id: {{ rust_types.rust_id_type(id_type) | trim}},
    pub created_at: DateTime,
    pub last_updated: DateTime,
    {% for name, property in entity.attributes | items -%}
    {%- if property.writeOnly -%}{% continue -%}{%- endif -%}
    pub {{ rust_types.rust_var(name,false) }}: {{ rust_types.get_rust_type(name, property) }} {{- ',' if not loop.last }}
    {% endfor %}
}

impl From<Model> for {{ entity_name | pascal_case }} {
    fn from(model: Model) -> Self {
        Self {
            id: model.id,
            created_at: model.created_at,
            last_updated: model.last_updated,
            {% for name, property in entity.attributes | items -%}
            {{ rust_types.rust_var(name,false) }}: {{ rust_types.from_model_value(name,property) }} {{- ',' if not loop.last }}
            {% endfor %}
        }
    }
}

impl From<ModelEx> for {{ entity_name | pascal_case }} {
    fn from(model: ModelEx) -> Self {
        Self {
            id: model.id,
            created_at: model.created_at,
            last_updated: model.last_updated,
            {% for name, property in entity.attributes | items -%}
            {% set var_name = rust_types.rust_var(name,false) -%}
            {% if property.writeOnly or macros.relation_is_many_to_many(property)=='true' or macros.relation_is_one_to_many(property=property)=='true'-%}
            {{ var_name }}: {{'Some(' if not property.required }}model.{{ var_name }}.into_iter().map({{ macros.get_relation(property) | pascal_case }}::from).collect(){{')' if not property.required}},
            {% elif macros.relation_is_many_to_one(property)=='true' or macros.relation_is_one_to_one(property=property)=='true'-%}
            {{ var_name }}: model.{{ var_name }}.into_option().map(|p| Box::new(p.into())){{'.unwrap_or_default()' if property.required}},
            {% elif property.type -%}
            {{ var_name }}: model.{{ var_name }},
            {% endif -%}
            {% endfor %}
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct {{ entity_name | pascal_case }}Create {
    {% for name, property in entity.attributes | items -%}
    {%- if property.readOnly-%}{% continue -%}{%- endif -%}
    pub {{ rust_types.rust_var(name,false) }}: {{ rust_types.get_rust_type(name, property) }} {{- ',' if not loop.last }}
    {% endfor %}
}

impl From<{{ entity_name | pascal_case }}Create> for ActiveModel {
    fn from(source: {{ entity_name | pascal_case }}Create) -> Self {
        ActiveModel {
            {% for name, property in entity.attributes | items -%}
            {%- if property.readOnly or macros.relation_is_many_to_many(property)=='true' or macros.relation_is_one_to_many(property)=='true' -%}{% continue -%}{%- endif -%}
            {%- if macros.relation_is_many_to_one(property)=='true' or macros.relation_is_one_to_one(property=property)=='true'-%}
            {{ name | snake_case }}_id: Set(source.{{ rust_types.rust_var(name,false) }}{{ '.unwrap_or_default()' if not property.required }}.id.clone()),
            {%- elif property.type  -%}
            {{ rust_types.rust_var(name,false) }}: Set(source.{{ name | snake_case }}.clone()),
            {% endif -%}
            {%- endfor -%}
            ..Default::default()
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct {{ entity_name | pascal_case }}Update {
    {% for name, property in entity.attributes | items -%}
    {%- if property.readOnly-%}{% continue -%}{%- endif -%}
    pub {{ rust_types.rust_var(name,false) }}: {{ rust_types.get_rust_type(name, property) }} {{- ',' if not loop.last }}
    {% endfor %}
}

impl {{ entity_name | pascal_case }}Update {
    fn into_active_model(self, id:{{ rust_types.rust_id_type(id_type) | trim}}) -> ActiveModel {
        ActiveModel {
            id: Set(id),
            {% for name, property in entity.attributes | items -%}
            {%- if property.readOnly or macros.relation_is_many_to_many(property)=='true' or macros.relation_is_one_to_many(property)=='true' -%}{% continue -%}{%- endif -%}
            {%- if macros.relation_is_many_to_one(property)=='true' or macros.relation_is_one_to_one(property=property)=='true'-%}
            {{ name | snake_case }}_id: Set(self.{{ rust_types.rust_var(name,false) }}{{ '.unwrap_or_default()' if not property.required }}.id.clone()),
            {% elif property.type  -%}
            {{ rust_types.rust_var(name,false) }}: Set(self.{{ name | snake_case }}.clone()),
            {% endif -%}
            {%- endfor -%}
            ..Default::default()
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct {{ entity_name | pascal_case }}Patch {
    {% for name, property in entity.attributes | items -%}
    {%- if property.readOnly-%}{% continue -%}{%- endif -%}
    {%- set base_type = rust_types.get_rust_primitive(name, property) -%}
    {%- if property.type == 'relation' -%}
        {%- if macros.relation_is_many_to_many(property)=='true' or macros.relation_is_one_to_many(property)=='true' -%}
            {%- set base_type = 'Vec<' ~ base_type ~ '>' -%}
        {%- elif macros.relation_is_many_to_one(property)=='true' or macros.relation_is_one_to_one(property)=='true' -%}
            {%- set base_type = 'Box<' ~ base_type ~ '>' -%}
        {%- endif -%}
    {%- endif -%}
    pub {{ rust_types.rust_var(name,false) }}: Option<{{ base_type }}> {{- ',' if not loop.last }}
    {% endfor %}
}

impl {{ entity_name | pascal_case }}Patch {
    pub fn patch_active_model(&self, active_model: &mut ActiveModel) {
        {% for name, property in entity.attributes | items -%}
        {%- if property.readOnly or macros.relation_is_many_to_many(property)=='true' or macros.relation_is_one_to_many(property)=='true' -%}{% continue -%}{%- endif -%}
        {%- if property.type -%}
        {%- set var_name = rust_types.rust_var(name,false) -%}
        {%- if macros.relation_is_many_to_one(property)=='true' or macros.relation_is_one_to_one(property)=='true' -%}
        if let Some(value) = &self.{{ var_name }} {
            active_model.{{ name | snake_case }}_id = Set(value.id.clone());
        }
        {%- elif property.required -%}
        if let Some(value) = &self.{{ var_name }} {
            active_model.{{ name | snake_case }} = Set(value.clone());
        }
        {%- else -%}
        if self.{{ var_name }}.is_some() {
            active_model.{{ name | snake_case }} = Set(self.{{ var_name }}.clone());
        }
        {%- endif -%}
        {% endif -%}
        {% endfor %}
    }
}

async fn load_item<C>(
    db: &C,
    id: i32,
) -> Result<Model, (StatusCode, Json<serde_json::Value>)>
where
    C: ConnectionTrait,
{
    Entity::find_by_id(id)
        .one(db)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, Json(json!({"error": e.to_string()}))))?
        .ok_or_else(|| (StatusCode::NOT_FOUND, Json(json!({"error": "not found"}))))
}

pub async fn list(state: State<AppState>) -> Result<impl IntoResponse, (StatusCode, Json<serde_json::Value>)> {
    let models = Entity::load()
        {% for name, property in entity.attributes | items -%}
        {%- if macros.is_relation(property)=='true' -%}
        .with(crate::models::{{ rust_types.identifier(macros.get_relation(property)) }}::Entity)
        {% endif -%}
        {% endfor -%}
        .all(&state.db)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, Json(json!({"error": e.to_string()}))))?;
    let responses: Vec<{{ entity_name | pascal_case }}> = models.into_iter().map(Into::into).collect();

    let total = responses.len() as u64;
    let start: u64 = 0;
    let end: u64 = if total == 0 { 0 } else { total - 1 };
    let mut headers = HeaderMap::new();
    let content_range_value = format!("items {}-{}/{}", start, end, total);
    headers.insert("Content-Range", HeaderValue::from_str(&content_range_value).unwrap());
    headers.insert("Accept-Ranges", HeaderValue::from_static("items"));
    Ok((StatusCode::OK, headers, Json(responses)))
}

pub async fn create(state: State<AppState>, Json(create): Json<{{ entity_name | pascal_case }}Create>) -> Result<impl IntoResponse, (StatusCode, Json<serde_json::Value>)> {
    let active_model:ActiveModel = create.into();
    let model = active_model.insert(&state.db)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, Json(json!({"failed to insert item": e.to_string()}))))?;
        let resp: {{ entity_name | pascal_case }} = model.into();
        Ok(Json(resp))

}

pub async fn patch_one(state: State<AppState>, Path(id): Path<i32>, Json(patch): Json<{{ entity_name | pascal_case }}Patch> ) -> Result<impl IntoResponse, (StatusCode, Json<serde_json::Value>)> {
    let model = load_item(&state.db, id).await?;
    let mut active_model = model.into_active_model();
    patch.patch_active_model(&mut active_model);
    let model = active_model.update(&state.db)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, Json(json!({"failed to update item": e.to_string()}))))?;
    let resp: {{ entity_name | pascal_case }} = model.into();
    Ok(Json(resp))
}

pub async fn put_one(state: State<AppState>, Path(id): Path<i32>, Json(update): Json<{{ entity_name | pascal_case }}Update>) -> Result<impl IntoResponse, (StatusCode, Json<serde_json::Value>)> {
    let _ = load_item(&state.db, id).await?;
    let active_model = update.into_active_model(id);
    let model = active_model.update(&state.db)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, Json(json!({"failed to update item": e.to_string()}))))?;
    let resp: {{ entity_name | pascal_case }} = model.into();
    Ok(Json(resp))
}

pub async fn remove(state: State<AppState>, Path(id): Path<i32>) -> Result<impl IntoResponse, (StatusCode, Json<serde_json::Value>)> {
    let model = load_item(&state.db, id).await?;
    model.delete(&state.db)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, Json(json!({"error": e.to_string()}))))?;
    Ok(StatusCode::NO_CONTENT)
}

pub async fn read_one(state: State<AppState>, Path(id): Path<i32>) -> Result<impl IntoResponse, (StatusCode, Json<serde_json::Value>)> {
    let model = Entity::load()
        .filter_by_id(id)
        {% for name, property in entity.attributes | items -%}
        {%- if macros.is_relation(property)=='true' -%}
        .with(crate::models::{{ rust_types.identifier(macros.get_relation(property)) }}::Entity)
        {% endif -%}
        {% endfor -%}
        .one(&state.db)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, Json(json!({"error": e.to_string()}))))?
        .ok_or_else(|| (StatusCode::NOT_FOUND, Json(json!({"error": "not found"}))))?;
    let resp: {{ entity_name | pascal_case }} = model.into();
    Ok(Json(resp))
}

pub fn routes() -> Router<AppState> {
    Router::new()
        .route("/{{ entity.info.name | plural | kebab_case  }}", get(list))
        .route("/{{ entity.info.name | plural | kebab_case  }}", post(create))
        .route("/{{ entity.info.name | plural | kebab_case  }}/{id}", get(read_one))
        .route("/{{ entity.info.name | plural | kebab_case  }}/{id}", delete(remove))
        .route("/{{ entity.info.name | plural | kebab_case  }}/{id}", patch(patch_one))
        .route("/{{ entity.info.name | plural | kebab_case  }}/{id}", put(put_one))
}
