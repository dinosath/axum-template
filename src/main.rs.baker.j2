use app_state::AppState;
use axum::{ {% if protocol=='rest' and authentication=='oauth2'-%}error_handling::HandleErrorLayer, http::Uri, response::IntoResponse,{% endif %} Router};
{% if protocol=='rest' and authentication=='oauth2'-%}
use axum_oidc::{
    error::MiddlewareError, EmptyAdditionalClaims, OidcAuthLayer, OidcLoginLayer
};
{% endif -%}
use log::{info, error};
{% if database=='postgres' -%}
use sea_orm::{Database, DatabaseConnection};
use sqlx::postgres::PgPoolOptions;
{% endif -%}
use std::env;
use tokio::net::TcpListener;
{% if protocol=='rest' and authentication=='oauth2'-%}
use tower::ServiceBuilder;
use tower_sessions::{
    cookie::{time::Duration, SameSite},
    Expiry, MemoryStore, SessionManagerLayer,
};
{% endif -%}
use utoipa::OpenApi;
use utoipa_axum::router::OpenApiRouter;
use utoipa_scalar::{Scalar, Servable};

{{ 'mod service;' if protocol=='grpc' }}
{{ 'mod models;' if database=='postgres' }}
{{ 'mod controllers;' if protocol=='rest' and crudcrate==false }}
mod app_state;

#[derive(OpenApi)]
#[openapi()]
struct ApiDoc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    dotenvy::dotenv().ok();
    env_logger::init();

    {% if database=='postgres'-%}
    let database_url = env::var("DATABASE_URL").unwrap_or_else(|_| "postgres://postgres:postgres@localhost:5432".to_string());
    let db: DatabaseConnection = Database::connect(&database_url).await?;

    info!("üîÑ Running database migrations...");
    let pool = PgPoolOptions::new()
        .max_connections(5)
        .connect(&database_url)
        .await?;

    if let Err(e) = sqlx::migrate!("./migrations")
        .run(&pool)
        .await
    {
        error!("‚ùå Failed to run database migrations: {}", e);
        return Err(e.into());
    }

    info!("‚úÖ Database migrations completed successfully!");
    {% endif -%}

    {% if protocol=='rest' and authentication=='oauth2'-%}
    let app_url = env::var("APP_URL").expect("APP_URL env variable");
    let issuer = env::var("ISSUER").expect("ISSUER env variable");
    let client_id = env::var("CLIENT_ID").expect("CLIENT_ID env variable");
    let client_secret = env::var("CLIENT_SECRET").ok();

    let session_store = MemoryStore::default();
    let session_layer = SessionManagerLayer::new(session_store)
        .with_secure(false)
        .with_same_site(SameSite::Lax)
        .with_expiry(Expiry::OnInactivity(Duration::seconds(120)));

    let oidc_login_service = ServiceBuilder::new()
        .layer(HandleErrorLayer::new(|e: MiddlewareError| async {
            e.into_response()
        }))
        .layer(OidcLoginLayer::<EmptyAdditionalClaims>::new());

    let oidc_auth_service = ServiceBuilder::new()
        .layer(HandleErrorLayer::new(|e: MiddlewareError| async {
            e.into_response()
        }))
        .layer(
            OidcAuthLayer::<EmptyAdditionalClaims>::discover_client(
                Uri::from_maybe_shared(app_url).expect("valid APP_URL"),
                issuer,
                client_id,
                client_secret,
                vec![],
            )
            .await
            .unwrap(),
        );
    {% endif -%}
    let state = AppState {  {{ 'db' if database=='postgres' -}} };
    let app_router = Router::new()
        {% for entity_name,entity in entities | items -%}
        .merge(controllers::{{entity_name | snake_case}}::routes())
        {% endfor -%}
        .with_state(state);

    {% if protocol=='rest' and authentication=='oauth2'-%}
    let app_router = app_router
        .layer(oidc_login_service)
        .layer(oidc_auth_service)
        .layer(session_layer);
    {% endif -%}

    let port = env::var("PORT").unwrap_or_else(|_| "8080".to_string());
    let listener = TcpListener::bind(format!("[::]:{}",port)).await.unwrap();
    info!("üöÄüöÄüöÄ Started axum web server on port 8080.");
    axum::serve(listener, app_router).await?;
    Ok(())
}